// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`frozen object > crossSerialize > scoped > supports Objects 1`] = `"($R=>($R[0]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"},Object.freeze($R[0]),$R[0]))($R["example"])"`;

exports[`frozen object > crossSerialize > scoped > supports Symbol.iterator 1`] = `
"($R=>($R[0]={[$R[1]=Symbol.iterator]:($R[2]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[1]))($R[3]={v:$R[4]=[1,2,3,void 0],t:-1,d:3})},Object.freeze($R[0]),$R[0]))($R["example"])"
`;

exports[`frozen object > crossSerialize > scoped > supports self-recursion 1`] = `"($R=>($R[0]={},$R[0].b=$R[0].a=$R[0],Object.freeze($R[0]),$R[0]))($R["example"])"`;

exports[`frozen object > crossSerialize > supports Objects 1`] = `"($R[0]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"},Object.freeze($R[0]),$R[0])"`;

exports[`frozen object > crossSerialize > supports Symbol.iterator 1`] = `
"($R[0]={[$R[1]=Symbol.iterator]:($R[2]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[1]))($R[3]={v:$R[4]=[1,2,3,void 0],t:-1,d:3})},Object.freeze($R[0]),$R[0])"
`;

exports[`frozen object > crossSerialize > supports self-recursion 1`] = `"($R[0]={},$R[0].b=$R[0].a=$R[0],Object.freeze($R[0]),$R[0])"`;

exports[`frozen object > crossSerializeAsync > scoped > supports Objects 1`] = `"($R=>($R[0]=Promise.resolve($R[1]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}),Object.freeze($R[1]),$R[0]))($R["example"])"`;

exports[`frozen object > crossSerializeAsync > scoped > supports Symbol.asyncIterator 1`] = `
"($R=>($R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))(($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[4].next(1),$R[4].next(2),$R[4].next(3),$R[4].return(void 0),$R[4]))},Object.freeze($R[0]),$R[0]))($R["example"])"
`;

exports[`frozen object > crossSerializeAsync > scoped > supports Symbol.iterator 1`] = `
"($R=>($R[0]=Promise.resolve($R[1]={[$R[2]=Symbol.iterator]:($R[3]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[2]))($R[4]={v:$R[5]=[1,2,3,void 0],t:-1,d:3})}),Object.freeze($R[1]),$R[0]))($R["example"])"
`;

exports[`frozen object > crossSerializeAsync > scoped > supports self-recursion 1`] = `"($R=>($R[0]={a:$R[1]=Promise.resolve().then(()=>$R[0]),b:$R[2]=Promise.resolve().then(()=>$R[0])},Object.freeze($R[0]),$R[0]))($R["example"])"`;

exports[`frozen object > crossSerializeAsync > supports Objects 1`] = `"($R[0]=Promise.resolve($R[1]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}),Object.freeze($R[1]),$R[0])"`;

exports[`frozen object > crossSerializeAsync > supports Symbol.asyncIterator 1`] = `
"($R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))(($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[4].next(1),$R[4].next(2),$R[4].next(3),$R[4].return(void 0),$R[4]))},Object.freeze($R[0]),$R[0])"
`;

exports[`frozen object > crossSerializeAsync > supports Symbol.iterator 1`] = `
"($R[0]=Promise.resolve($R[1]={[$R[2]=Symbol.iterator]:($R[3]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[2]))($R[4]={v:$R[5]=[1,2,3,void 0],t:-1,d:3})}),Object.freeze($R[1]),$R[0])"
`;

exports[`frozen object > crossSerializeAsync > supports self-recursion 1`] = `"($R[0]={a:$R[1]=Promise.resolve().then(()=>$R[0]),b:$R[2]=Promise.resolve().then(()=>$R[0])},Object.freeze($R[0]),$R[0])"`;

exports[`frozen object > crossSerializeStream > scoped > supports Objects 1`] = `
"($R=>$R[0]=($R[2]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
})($R[1]={p:0,s:0,f:0}))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports Objects 2`] = `
"($R=>(($R[4]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}),Object.freeze($R[3]),$R[1]))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.asyncIterator 1`] = `
"($R=>($R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})())},Object.freeze($R[0]),$R[0]))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.asyncIterator 2`] = `"($R=>$R[4].next(1))($R["example"])"`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.asyncIterator 3`] = `"($R=>$R[4].next(2))($R["example"])"`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.asyncIterator 4`] = `"($R=>$R[4].next(3))($R["example"])"`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.asyncIterator 5`] = `"($R=>$R[4].return(void 0))($R["example"])"`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.iterator 1`] = `
"($R=>$R[0]=($R[2]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
})($R[1]={p:0,s:0,f:0}))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports Symbol.iterator 2`] = `
"($R=>(($R[8]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={[$R[4]=Symbol.iterator]:($R[5]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[4]))($R[6]={v:$R[7]=[1,2,3,void 0],t:-1,d:3})}),Object.freeze($R[3]),$R[1]))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports self-recursion 1`] = `
"($R=>($R[0]={a:$R[1]=($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
})($R[2]={p:0,s:0,f:0}),b:$R[4]=$R[3]($R[5]={p:0,s:0,f:0})},Object.freeze($R[0]),$R[0]))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports self-recursion 2`] = `
"($R=>($R[6]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[2],$R[0]))($R["example"])"
`;

exports[`frozen object > crossSerializeStream > scoped > supports self-recursion 3`] = `"($R=>$R[6]($R[5],$R[0]))($R["example"])"`;

exports[`frozen object > crossSerializeStream > supports Objects 1`] = `
"$R[0]=($R[2]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
})($R[1]={p:0,s:0,f:0})"
`;

exports[`frozen object > crossSerializeStream > supports Objects 2`] = `
"(($R[4]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}),Object.freeze($R[3]),$R[1])"
`;

exports[`frozen object > crossSerializeStream > supports Symbol.asyncIterator 1`] = `
"($R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})())},Object.freeze($R[0]),$R[0])"
`;

exports[`frozen object > crossSerializeStream > supports Symbol.asyncIterator 2`] = `"$R[4].next(1)"`;

exports[`frozen object > crossSerializeStream > supports Symbol.asyncIterator 3`] = `"$R[4].next(2)"`;

exports[`frozen object > crossSerializeStream > supports Symbol.asyncIterator 4`] = `"$R[4].next(3)"`;

exports[`frozen object > crossSerializeStream > supports Symbol.asyncIterator 5`] = `"$R[4].return(void 0)"`;

exports[`frozen object > crossSerializeStream > supports Symbol.iterator 1`] = `
"$R[0]=($R[2]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
})($R[1]={p:0,s:0,f:0})"
`;

exports[`frozen object > crossSerializeStream > supports Symbol.iterator 2`] = `
"(($R[8]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={[$R[4]=Symbol.iterator]:($R[5]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[4]))($R[6]={v:$R[7]=[1,2,3,void 0],t:-1,d:3})}),Object.freeze($R[3]),$R[1])"
`;

exports[`frozen object > crossSerializeStream > supports self-recursion 1`] = `
"($R[0]={a:$R[1]=($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
})($R[2]={p:0,s:0,f:0}),b:$R[4]=$R[3]($R[5]={p:0,s:0,f:0})},Object.freeze($R[0]),$R[0])"
`;

exports[`frozen object > crossSerializeStream > supports self-recursion 2`] = `
"($R[6]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[2],$R[0])"
`;

exports[`frozen object > crossSerializeStream > supports self-recursion 3`] = `"$R[6]($R[5],$R[0])"`;

exports[`frozen object > serialize > supports Objects 1`] = `"(h=>(h={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"},Object.freeze(h),h))()"`;

exports[`frozen object > serialize > supports Symbol.iterator 1`] = `
"((h,j,k)=>(h={[j=Symbol.iterator]:(((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})(j))({v:[1,2,3,void 0],t:-1,d:3})},Object.freeze(h),h))()"
`;

exports[`frozen object > serialize > supports self-recursion 1`] = `"(h=>(h={},h.b=h.a=h,Object.freeze(h),h))()"`;

exports[`frozen object > serializeAsync > supports Objects 1`] = `"((h,j)=>(j=Promise.resolve(h={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}),Object.freeze(h),j))()"`;

exports[`frozen object > serializeAsync > supports Symbol.asyncIterator 1`] = `
"((h,j,k,m,o,q)=>(h={[j=Symbol.asyncIterator]:((k=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})(j,k)))((q=(() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),q.next(1),q.next(2),q.next(3),q.return(void 0),q))},Object.freeze(h),h))()"
`;

exports[`frozen object > serializeAsync > supports Symbol.iterator 1`] = `
"((h,j,k,m)=>(m=Promise.resolve(h={[j=Symbol.iterator]:(((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})(j))({v:[1,2,3,void 0],t:-1,d:3})}),Object.freeze(h),m))()"
`;

exports[`frozen object > serializeAsync > supports self-recursion 1`] = `"(h=>(h={a:Promise.resolve().then(()=>h),b:Promise.resolve().then(()=>h)},Object.freeze(h),h))()"`;

exports[`frozen object > toCrossJSON > supports Objects 1`] = `"{"t":10,"i":0,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":3}"`;

exports[`frozen object > toCrossJSON > supports Symbol.iterator 1`] = `"{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":2,"f":{"t":4,"i":1}},{"t":10,"i":3,"p":{"k":["v","t","d"],"v":[{"t":9,"i":4,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":3}"`;

exports[`frozen object > toCrossJSON > supports self-recursion 1`] = `"{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":4,"i":0},{"t":4,"i":0}],"s":2},"o":3}"`;

exports[`frozen object > toCrossJSONAsync > supports Objects 1`] = `"{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":3}}"`;

exports[`frozen object > toCrossJSONAsync > supports Symbol.asyncIterator 1`] = `"{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":0}],"v":[{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[{"t":32,"i":4,"f":{"t":0,"s":1}},{"t":32,"i":4,"f":{"t":0,"s":2}},{"t":32,"i":4,"f":{"t":0,"s":3}},{"t":34,"i":4,"f":{"t":2,"s":1}}],"f":{"t":26,"i":5,"s":4}}]}],"s":1},"o":3}"`;

exports[`frozen object > toCrossJSONAsync > supports Symbol.iterator 1`] = `"{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":[{"t":17,"i":2,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":3,"f":{"t":4,"i":2}},{"t":10,"i":4,"p":{"k":["v","t","d"],"v":[{"t":9,"i":5,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":3}}"`;

exports[`frozen object > toCrossJSONAsync > supports self-recursion 1`] = `"{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":12,"i":1,"s":1,"f":{"t":4,"i":0}},{"t":12,"i":2,"s":1,"f":{"t":4,"i":0}}],"s":2},"o":3}"`;

exports[`frozen object > toCrossJSONStream > supports Objects 1`] = `"{"t":22,"i":0,"s":1,"f":{"t":26,"i":2,"s":1}}"`;

exports[`frozen object > toCrossJSONStream > supports Objects 2`] = `"{"t":23,"i":1,"a":[{"t":26,"i":4,"s":2},{"t":10,"i":3,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":3}]}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.asyncIterator 1`] = `"{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":0}],"v":[{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[],"f":{"t":26,"i":5,"s":4}}]}],"s":1},"o":3}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.asyncIterator 2`] = `"{"t":32,"i":4,"f":{"t":0,"s":1}}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.asyncIterator 3`] = `"{"t":32,"i":4,"f":{"t":0,"s":2}}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.asyncIterator 4`] = `"{"t":32,"i":4,"f":{"t":0,"s":3}}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.asyncIterator 5`] = `"{"t":34,"i":4,"f":{"t":2,"s":1}}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.iterator 1`] = `"{"t":22,"i":0,"s":1,"f":{"t":26,"i":2,"s":1}}"`;

exports[`frozen object > toCrossJSONStream > supports Symbol.iterator 2`] = `"{"t":23,"i":1,"a":[{"t":26,"i":8,"s":2},{"t":10,"i":3,"p":{"k":[{"t":17,"i":4,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":5,"f":{"t":4,"i":4}},{"t":10,"i":6,"p":{"k":["v","t","d"],"v":[{"t":9,"i":7,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":3}]}"`;

exports[`frozen object > toCrossJSONStream > supports self-recursion 1`] = `"{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":22,"i":1,"s":2,"f":{"t":26,"i":3,"s":1}},{"t":22,"i":4,"s":5,"f":{"t":4,"i":3}}],"s":2},"o":3}"`;

exports[`frozen object > toCrossJSONStream > supports self-recursion 2`] = `"{"t":23,"i":2,"a":[{"t":26,"i":6,"s":2},{"t":4,"i":0}]}"`;

exports[`frozen object > toCrossJSONStream > supports self-recursion 3`] = `"{"t":23,"i":5,"a":[{"t":4,"i":6},{"t":4,"i":0}]}"`;

exports[`frozen object > toJSON > supports Objects 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":3},"f":31,"m":[]}"`;

exports[`frozen object > toJSON > supports Symbol.iterator 1`] = `"{"t":{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":2,"f":{"t":4,"i":1}},{"t":10,"i":3,"p":{"k":["v","t","d"],"v":[{"t":9,"i":4,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":3},"f":31,"m":[1]}"`;

exports[`frozen object > toJSON > supports self-recursion 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":4,"i":0},{"t":4,"i":0}],"s":2},"o":3},"f":31,"m":[0]}"`;

exports[`frozen object > toJSONAsync > supports Objects 1`] = `"{"t":{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":3}},"f":31,"m":[]}"`;

exports[`frozen object > toJSONAsync > supports Symbol.asyncIterator 1`] = `"{"t":{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":0}],"v":[{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[{"t":32,"i":4,"f":{"t":0,"s":1}},{"t":32,"i":4,"f":{"t":0,"s":2}},{"t":32,"i":4,"f":{"t":0,"s":3}},{"t":34,"i":4,"f":{"t":2,"s":1}}],"f":{"t":26,"i":5,"s":4}}]}],"s":1},"o":3},"f":31,"m":[1,4]}"`;

exports[`frozen object > toJSONAsync > supports Symbol.iterator 1`] = `"{"t":{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":[{"t":17,"i":2,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":3,"f":{"t":4,"i":2}},{"t":10,"i":4,"p":{"k":["v","t","d"],"v":[{"t":9,"i":5,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":3}},"f":31,"m":[2]}"`;

exports[`frozen object > toJSONAsync > supports self-recursion 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":12,"i":1,"s":1,"f":{"t":4,"i":0}},{"t":12,"i":2,"s":1,"f":{"t":4,"i":0}}],"s":2},"o":3},"f":31,"m":[0]}"`;
