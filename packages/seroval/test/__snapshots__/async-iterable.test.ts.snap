// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`AsyncIterable > crossSerializeAsync > scoped > supports AsyncIterables 1`] = `
"($R=>$R[0]={title:"Hello World",[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => (instance, buffer = [], count = 0, pending = [], doneAt = -1, isThrow = false, finalize = (i = 0, len = pending.length) => {
  for (; i < len; i++) {
    pending[i].s({
      done: true,
      value: void 0
    });
  }
}) => {
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      }
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      }
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      }
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  instance = {
    [symbol]: () => instance,
    next: (index, temp, value) => {
      if (doneAt === -1) {
        index = count++;
        if (index >= buffer.length) {
          temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        }
        return {
          done: false,
          value: buffer[index]
        };
      }
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      }
      index = count++;
      value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      }
      if (isThrow) {
        throw value;
      }
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))(($R[4]=($R[5]=(buffer = [], alive = true, success = false, listeners = [], count = 0, flush = (value, mode, x) => {
  for (x = 0; x < count; x++) {
    if (listeners[x]) {
      listeners[x][mode](value);
    }
  }
}, up = (listener, x, z, current) => {
  for (x = 0, z = buffer.length; x < z; x++) {
    current = buffer[x];
    if (!alive && x === z - 1) {
      listener[success ? "return" : "throw"](current);
    } else {
      listener.next(current);
    }
  }
}, on = (listener, temp) => {
  if (alive) {
    temp = count++;
    listeners[temp] = listener;
  }
  up(listener);
  return () => {
    if (alive) {
      listeners[temp] = listeners[count];
      listeners[count--] = void 0;
    }
  };
}) => ({
  __SEROVAL_STREAM__: true,
  on: (listener) => on(listener),
  next: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "next");
    }
  },
  throw: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "throw");
      alive = false;
      success = false;
      listeners.length = 0;
    }
  },
  return: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "return");
      alive = false;
      success = true;
      listeners.length = 0;
    }
  }
}))(),$R[4].next(1),$R[4].next(2),$R[4].next(3),$R[4].return(void 0),$R[4]))})($R["example"])"
`;

exports[`AsyncIterable > crossSerializeAsync > supports AsyncIterables 1`] = `
"($R[0]={title:"Hello World",[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => (instance, buffer = [], count = 0, pending = [], doneAt = -1, isThrow = false, finalize = (i = 0, len = pending.length) => {
  for (; i < len; i++) {
    pending[i].s({
      done: true,
      value: void 0
    });
  }
}) => {
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      }
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      }
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      }
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  instance = {
    [symbol]: () => instance,
    next: (index, temp, value) => {
      if (doneAt === -1) {
        index = count++;
        if (index >= buffer.length) {
          temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        }
        return {
          done: false,
          value: buffer[index]
        };
      }
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      }
      index = count++;
      value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      }
      if (isThrow) {
        throw value;
      }
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))(($R[4]=($R[5]=(buffer = [], alive = true, success = false, listeners = [], count = 0, flush = (value, mode, x) => {
  for (x = 0; x < count; x++) {
    if (listeners[x]) {
      listeners[x][mode](value);
    }
  }
}, up = (listener, x, z, current) => {
  for (x = 0, z = buffer.length; x < z; x++) {
    current = buffer[x];
    if (!alive && x === z - 1) {
      listener[success ? "return" : "throw"](current);
    } else {
      listener.next(current);
    }
  }
}, on = (listener, temp) => {
  if (alive) {
    temp = count++;
    listeners[temp] = listener;
  }
  up(listener);
  return () => {
    if (alive) {
      listeners[temp] = listeners[count];
      listeners[count--] = void 0;
    }
  };
}) => ({
  __SEROVAL_STREAM__: true,
  on: (listener) => on(listener),
  next: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "next");
    }
  },
  throw: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "throw");
      alive = false;
      success = false;
      listeners.length = 0;
    }
  },
  return: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "return");
      alive = false;
      success = true;
      listeners.length = 0;
    }
  }
}))(),$R[4].next(1),$R[4].next(2),$R[4].next(3),$R[4].return(void 0),$R[4]))})"
`;

exports[`AsyncIterable > crossSerializeStream > scoped > supports AsyncIterables 1`] = `
"($R=>$R[0]={title:"Hello World",[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => (instance, buffer = [], count = 0, pending = [], doneAt = -1, isThrow = false, finalize = (i = 0, len = pending.length) => {
  for (; i < len; i++) {
    pending[i].s({
      done: true,
      value: void 0
    });
  }
}) => {
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      }
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      }
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      }
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  instance = {
    [symbol]: () => instance,
    next: (index, temp, value) => {
      if (doneAt === -1) {
        index = count++;
        if (index >= buffer.length) {
          temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        }
        return {
          done: false,
          value: buffer[index]
        };
      }
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      }
      index = count++;
      value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      }
      if (isThrow) {
        throw value;
      }
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))($R[4]=($R[5]=(buffer = [], alive = true, success = false, listeners = [], count = 0, flush = (value, mode, x) => {
  for (x = 0; x < count; x++) {
    if (listeners[x]) {
      listeners[x][mode](value);
    }
  }
}, up = (listener, x, z, current) => {
  for (x = 0, z = buffer.length; x < z; x++) {
    current = buffer[x];
    if (!alive && x === z - 1) {
      listener[success ? "return" : "throw"](current);
    } else {
      listener.next(current);
    }
  }
}, on = (listener, temp) => {
  if (alive) {
    temp = count++;
    listeners[temp] = listener;
  }
  up(listener);
  return () => {
    if (alive) {
      listeners[temp] = listeners[count];
      listeners[count--] = void 0;
    }
  };
}) => ({
  __SEROVAL_STREAM__: true,
  on: (listener) => on(listener),
  next: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "next");
    }
  },
  throw: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "throw");
      alive = false;
      success = false;
      listeners.length = 0;
    }
  },
  return: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "return");
      alive = false;
      success = true;
      listeners.length = 0;
    }
  }
}))())})($R["example"])"
`;

exports[`AsyncIterable > crossSerializeStream > scoped > supports AsyncIterables 2`] = `"($R=>$R[4].next(1))($R["example"])"`;

exports[`AsyncIterable > crossSerializeStream > scoped > supports AsyncIterables 3`] = `"($R=>$R[4].next(2))($R["example"])"`;

exports[`AsyncIterable > crossSerializeStream > scoped > supports AsyncIterables 4`] = `"($R=>$R[4].next(3))($R["example"])"`;

exports[`AsyncIterable > crossSerializeStream > scoped > supports AsyncIterables 5`] = `"($R=>$R[4].return(void 0))($R["example"])"`;

exports[`AsyncIterable > crossSerializeStream > supports AsyncIterables 1`] = `
"($R[0]={title:"Hello World",[$R[1]=Symbol.asyncIterator]:(($R[3]=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},$R[2]=((symbol, createPromise) => (stream) => (instance, buffer = [], count = 0, pending = [], doneAt = -1, isThrow = false, finalize = (i = 0, len = pending.length) => {
  for (; i < len; i++) {
    pending[i].s({
      done: true,
      value: void 0
    });
  }
}) => {
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      }
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      }
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      }
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  instance = {
    [symbol]: () => instance,
    next: (index, temp, value) => {
      if (doneAt === -1) {
        index = count++;
        if (index >= buffer.length) {
          temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        }
        return {
          done: false,
          value: buffer[index]
        };
      }
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      }
      index = count++;
      value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      }
      if (isThrow) {
        throw value;
      }
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))($R[4]=($R[5]=(buffer = [], alive = true, success = false, listeners = [], count = 0, flush = (value, mode, x) => {
  for (x = 0; x < count; x++) {
    if (listeners[x]) {
      listeners[x][mode](value);
    }
  }
}, up = (listener, x, z, current) => {
  for (x = 0, z = buffer.length; x < z; x++) {
    current = buffer[x];
    if (!alive && x === z - 1) {
      listener[success ? "return" : "throw"](current);
    } else {
      listener.next(current);
    }
  }
}, on = (listener, temp) => {
  if (alive) {
    temp = count++;
    listeners[temp] = listener;
  }
  up(listener);
  return () => {
    if (alive) {
      listeners[temp] = listeners[count];
      listeners[count--] = void 0;
    }
  };
}) => ({
  __SEROVAL_STREAM__: true,
  on: (listener) => on(listener),
  next: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "next");
    }
  },
  throw: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "throw");
      alive = false;
      success = false;
      listeners.length = 0;
    }
  },
  return: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "return");
      alive = false;
      success = true;
      listeners.length = 0;
    }
  }
}))())})"
`;

exports[`AsyncIterable > crossSerializeStream > supports AsyncIterables 2`] = `"$R[4].next(1)"`;

exports[`AsyncIterable > crossSerializeStream > supports AsyncIterables 3`] = `"$R[4].next(2)"`;

exports[`AsyncIterable > crossSerializeStream > supports AsyncIterables 4`] = `"$R[4].next(3)"`;

exports[`AsyncIterable > crossSerializeStream > supports AsyncIterables 5`] = `"$R[4].return(void 0)"`;

exports[`AsyncIterable > serializeAsync > supports AsyncIterables 1`] = `
"((h,j,k,m,o)=>({title:"Hello World",[h=Symbol.asyncIterator]:((j=(resolver) => {
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver.p;
},((symbol, createPromise) => (stream) => (instance, buffer = [], count = 0, pending = [], doneAt = -1, isThrow = false, finalize = (i = 0, len = pending.length) => {
  for (; i < len; i++) {
    pending[i].s({
      done: true,
      value: void 0
    });
  }
}) => {
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      }
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      }
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      }
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  instance = {
    [symbol]: () => instance,
    next: (index, temp, value) => {
      if (doneAt === -1) {
        index = count++;
        if (index >= buffer.length) {
          temp = {
            p: 0,
            s: 0,
            f: 0
          };
          createPromise(temp);
          pending.push(temp);
          return temp.p;
        }
        return {
          done: false,
          value: buffer[index]
        };
      }
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      }
      index = count++;
      value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      }
      if (isThrow) {
        throw value;
      }
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})(h,j)))((o=((buffer = [], alive = true, success = false, listeners = [], count = 0, flush = (value, mode, x) => {
  for (x = 0; x < count; x++) {
    if (listeners[x]) {
      listeners[x][mode](value);
    }
  }
}, up = (listener, x, z, current) => {
  for (x = 0, z = buffer.length; x < z; x++) {
    current = buffer[x];
    if (!alive && x === z - 1) {
      listener[success ? "return" : "throw"](current);
    } else {
      listener.next(current);
    }
  }
}, on = (listener, temp) => {
  if (alive) {
    temp = count++;
    listeners[temp] = listener;
  }
  up(listener);
  return () => {
    if (alive) {
      listeners[temp] = listeners[count];
      listeners[count--] = void 0;
    }
  };
}) => ({
  __SEROVAL_STREAM__: true,
  on: (listener) => on(listener),
  next: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "next");
    }
  },
  throw: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "throw");
      alive = false;
      success = false;
      listeners.length = 0;
    }
  },
  return: (value) => {
    if (alive) {
      buffer.push(value);
      flush(value, "return");
      alive = false;
      success = true;
      listeners.length = 0;
    }
  }
}))(),o.next(1),o.next(2),o.next(3),o.return(void 0),o))}))()"
`;

exports[`AsyncIterable > toCrossJSONAsync > supports AsyncIterables 1`] = `"{"t":10,"i":0,"p":{"k":["title",{"t":17,"i":1,"s":0}],"v":[{"t":1,"s":"Hello World"},{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[{"t":32,"i":4,"f":{"t":0,"s":1}},{"t":32,"i":4,"f":{"t":0,"s":2}},{"t":32,"i":4,"f":{"t":0,"s":3}},{"t":34,"i":4,"f":{"t":2,"s":1}}],"f":{"t":26,"i":5,"s":4}}]}],"s":2},"o":0}"`;

exports[`AsyncIterable > toCrossJSONStream > supports AsyncIterables 1`] = `"{"t":10,"i":0,"p":{"k":["title",{"t":17,"i":1,"s":0}],"v":[{"t":1,"s":"Hello World"},{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[],"f":{"t":26,"i":5,"s":4}}]}],"s":2},"o":0}"`;

exports[`AsyncIterable > toCrossJSONStream > supports AsyncIterables 2`] = `"{"t":32,"i":4,"f":{"t":0,"s":1}}"`;

exports[`AsyncIterable > toCrossJSONStream > supports AsyncIterables 3`] = `"{"t":32,"i":4,"f":{"t":0,"s":2}}"`;

exports[`AsyncIterable > toCrossJSONStream > supports AsyncIterables 4`] = `"{"t":32,"i":4,"f":{"t":0,"s":3}}"`;

exports[`AsyncIterable > toCrossJSONStream > supports AsyncIterables 5`] = `"{"t":34,"i":4,"f":{"t":2,"s":1}}"`;

exports[`AsyncIterable > toJSONAsync > supports AsyncIterables 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["title",{"t":17,"i":1,"s":0}],"v":[{"t":1,"s":"Hello World"},{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[{"t":32,"i":4,"f":{"t":0,"s":1}},{"t":32,"i":4,"f":{"t":0,"s":2}},{"t":32,"i":4,"f":{"t":0,"s":3}},{"t":34,"i":4,"f":{"t":2,"s":1}}],"f":{"t":26,"i":5,"s":4}}]}],"s":2},"o":0},"f":31,"m":[1,4]}"`;
