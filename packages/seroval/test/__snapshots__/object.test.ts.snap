// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`objects > compat > should use manual assignment instead of Object.assign 1`] = `"({example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"`;

exports[`objects > compat#toJSON > should use manual assignment instead of Object.assign 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":0},"f":23,"m":[]}"`;

exports[`objects > compat#toJSON > should use manual assignment instead of Object.assign 2`] = `"({example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"`;

exports[`objects > crossSerialize > scoped > supports Objects 1`] = `"($R=>$R[0]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})($R["example"])"`;

exports[`objects > crossSerialize > scoped > supports Symbol.iterator 1`] = `
"($R=>$R[0]={[$R[1]=Symbol.iterator]:($R[2]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[1]))($R[3]={v:$R[4]=[1,2,3,void 0],t:-1,d:3})})($R["example"])"
`;

exports[`objects > crossSerialize > scoped > supports self-recursion 1`] = `"($R=>($R[0]={},$R[0].b=$R[0].a=$R[0],$R[0]))($R["example"])"`;

exports[`objects > crossSerialize > supports Objects 1`] = `"($R[0]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"`;

exports[`objects > crossSerialize > supports Symbol.iterator 1`] = `
"($R[0]={[$R[1]=Symbol.iterator]:($R[2]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[1]))($R[3]={v:$R[4]=[1,2,3,void 0],t:-1,d:3})})"
`;

exports[`objects > crossSerialize > supports self-recursion 1`] = `"($R[0]={},$R[0].b=$R[0].a=$R[0],$R[0])"`;

exports[`objects > crossSerializeAsync > scoped > supports Objects 1`] = `"($R=>$R[0]=Promise.resolve($R[1]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}))($R["example"])"`;

exports[`objects > crossSerializeAsync > scoped > supports Symbol.asyncIterator 1`] = `
"($R=>$R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = createPromise();
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))(($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[4].next(1),$R[4].next(2),$R[4].next(3),$R[4].return(void 0),$R[4]))})($R["example"])"
`;

exports[`objects > crossSerializeAsync > scoped > supports Symbol.iterator 1`] = `
"($R=>$R[0]=Promise.resolve($R[1]={[$R[2]=Symbol.iterator]:($R[3]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[2]))($R[4]={v:$R[5]=[1,2,3,void 0],t:-1,d:3})}))($R["example"])"
`;

exports[`objects > crossSerializeAsync > scoped > supports self-recursion 1`] = `"($R=>$R[0]={a:$R[1]=Promise.resolve().then(() => $R[0]),b:$R[2]=Promise.resolve().then(() => $R[0])})($R["example"])"`;

exports[`objects > crossSerializeAsync > supports Objects 1`] = `"$R[0]=Promise.resolve($R[1]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"`;

exports[`objects > crossSerializeAsync > supports Symbol.asyncIterator 1`] = `
"($R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = createPromise();
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))(($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[4].next(1),$R[4].next(2),$R[4].next(3),$R[4].return(void 0),$R[4]))})"
`;

exports[`objects > crossSerializeAsync > supports Symbol.iterator 1`] = `
"$R[0]=Promise.resolve($R[1]={[$R[2]=Symbol.iterator]:($R[3]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[2]))($R[4]={v:$R[5]=[1,2,3,void 0],t:-1,d:3})})"
`;

exports[`objects > crossSerializeAsync > supports self-recursion 1`] = `"($R[0]={a:$R[1]=Promise.resolve().then(() => $R[0]),b:$R[2]=Promise.resolve().then(() => $R[0])})"`;

exports[`objects > crossSerializeStream > scoped > supports Objects 1`] = `
"($R=>$R[0]=($R[1]=($R[2]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
})()).p)($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports Objects 2`] = `
"($R=>($R[4]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"}))($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.asyncIterator 1`] = `
"($R=>$R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = createPromise();
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})())})($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.asyncIterator 2`] = `"($R=>$R[4].next(1))($R["example"])"`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.asyncIterator 3`] = `"($R=>$R[4].next(2))($R["example"])"`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.asyncIterator 4`] = `"($R=>$R[4].next(3))($R["example"])"`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.asyncIterator 5`] = `"($R=>$R[4].return(void 0))($R["example"])"`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.iterator 1`] = `
"($R=>$R[0]=($R[1]=($R[2]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
})()).p)($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports Symbol.iterator 2`] = `
"($R=>($R[8]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={[$R[4]=Symbol.iterator]:($R[5]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[4]))($R[6]={v:$R[7]=[1,2,3,void 0],t:-1,d:3})}))($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports self-recursion 1`] = `
"($R=>$R[0]={a:$R[1]=($R[2]=($R[3]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
})()).p,b:$R[4]=($R[5]=$R[3]()).p})($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports self-recursion 2`] = `
"($R=>($R[6]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[2],$R[0]))($R["example"])"
`;

exports[`objects > crossSerializeStream > scoped > supports self-recursion 3`] = `"($R=>$R[6]($R[5],$R[0]))($R["example"])"`;

exports[`objects > crossSerializeStream > supports Objects 1`] = `
"$R[0]=($R[1]=($R[2]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
})()).p"
`;

exports[`objects > crossSerializeStream > supports Objects 2`] = `
"($R[4]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"
`;

exports[`objects > crossSerializeStream > supports Symbol.asyncIterator 1`] = `
"($R[0]={[$R[1]=Symbol.asyncIterator]:(($R[3]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
},$R[2]=((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = createPromise();
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})($R[1],$R[3])))($R[4]=($R[5]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})())})"
`;

exports[`objects > crossSerializeStream > supports Symbol.asyncIterator 2`] = `"$R[4].next(1)"`;

exports[`objects > crossSerializeStream > supports Symbol.asyncIterator 3`] = `"$R[4].next(2)"`;

exports[`objects > crossSerializeStream > supports Symbol.asyncIterator 4`] = `"$R[4].next(3)"`;

exports[`objects > crossSerializeStream > supports Symbol.asyncIterator 5`] = `"$R[4].return(void 0)"`;

exports[`objects > crossSerializeStream > supports Symbol.iterator 1`] = `
"$R[0]=($R[1]=($R[2]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
})()).p"
`;

exports[`objects > crossSerializeStream > supports Symbol.iterator 2`] = `
"($R[8]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[1],$R[3]={[$R[4]=Symbol.iterator]:($R[5]=((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})($R[4]))($R[6]={v:$R[7]=[1,2,3,void 0],t:-1,d:3})})"
`;

exports[`objects > crossSerializeStream > supports self-recursion 1`] = `
"($R[0]={a:$R[1]=($R[2]=($R[3]=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
})()).p,b:$R[4]=($R[5]=$R[3]()).p})"
`;

exports[`objects > crossSerializeStream > supports self-recursion 2`] = `
"($R[6]=(resolver, data) => {
  resolver.s(data);
  resolver.p.s = 1;
  resolver.p.v = data;
})($R[2],$R[0])"
`;

exports[`objects > crossSerializeStream > supports self-recursion 3`] = `"$R[6]($R[5],$R[0])"`;

exports[`objects > serialize > supports Objects 1`] = `"({example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"`;

exports[`objects > serialize > supports Symbol.iterator 1`] = `
"(h=>({[h=Symbol.iterator]:(((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})(h))({v:[1,2,3,void 0],t:-1,d:3})}))()"
`;

exports[`objects > serialize > supports self-recursion 1`] = `"(h=>(h={},h.b=h.a=h,h))()"`;

exports[`objects > serializeAsync > supports Objects 1`] = `"Promise.resolve({example:"valid identifier","%example":"invalid identifier","0x1":"hexadecimal","0b1":"binary","0o1":"octal","1_000":"numeric separator",1.7976931348623157e+308:"exponentiation"})"`;

exports[`objects > serializeAsync > supports Symbol.asyncIterator 1`] = `
"((h,j,k)=>({[h=Symbol.asyncIterator]:((j=() => {
  const resolver = { p: 0, s: 0, f: 0 };
  resolver.p = new Promise((resolve, reject) => {
    resolver.s = resolve;
    resolver.f = reject;
  });
  return resolver;
},((symbol, createPromise) => (stream) => () => {
  let count = 0;
  let doneAt = -1;
  let isThrow = false;
  const buffer = [];
  const pending = [];
  const finalize = (i = 0, len = pending.length) => {
    for (; i < len; i++) {
      pending[i].s({
        done: true,
        value: void 0
      });
    }
  };
  stream.on({
    next: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: false, value });
      };
      buffer.push(value);
    },
    throw: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.f(value);
      };
      finalize();
      doneAt = buffer.length;
      isThrow = true;
      buffer.push(value);
    },
    return: (value) => {
      const temp = pending.shift();
      if (temp) {
        temp.s({ done: true, value });
      };
      finalize();
      doneAt = buffer.length;
      buffer.push(value);
    }
  });
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (doneAt === -1) {
        const index2 = count++;
        if (index2 >= buffer.length) {
          const temp = createPromise();
          pending.push(temp);
          return temp.p;
        };
        return {
          done: false,
          value: buffer[index2]
        };
      };
      if (count > doneAt) {
        return {
          done: true,
          value: void 0
        };
      };
      const index = count++;
      const value = buffer[index];
      if (index !== doneAt) {
        return {
          done: false,
          value
        };
      };
      if (isThrow) {
        throw value;
      };
      return {
        done: true,
        value
      };
    }
  };
  return instance;
})(h,j)))((k=(() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),k.next(1),k.next(2),k.next(3),k.return(void 0),k))}))()"
`;

exports[`objects > serializeAsync > supports Symbol.iterator 1`] = `
"(h=>Promise.resolve({[h=Symbol.iterator]:(((symbol) => (sequence) => () => {
  let index = 0;
  const instance = {
    [symbol]: () => instance,
    next: () => {
      if (index > sequence.d) {
        return {
          done: true,
          value: void 0
        };
      };
      const currentIndex = index++;
      const data = sequence.v[currentIndex];
      if (currentIndex === sequence.t) {
        throw data;
      };
      return {
        done: currentIndex === sequence.d,
        value: data
      };
    }
  };
  return instance;
})(h))({v:[1,2,3,void 0],t:-1,d:3})}))()"
`;

exports[`objects > serializeAsync > supports self-recursion 1`] = `"(h=>h={a:Promise.resolve().then(() => h),b:Promise.resolve().then(() => h)})()"`;

exports[`objects > toCrossJSON > supports Objects 1`] = `"{"t":10,"i":0,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":0}"`;

exports[`objects > toCrossJSON > supports Symbol.iterator 1`] = `"{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":2,"f":{"t":4,"i":1}},{"t":10,"i":3,"p":{"k":["v","t","d"],"v":[{"t":9,"i":4,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":0}"`;

exports[`objects > toCrossJSON > supports self-recursion 1`] = `"{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":4,"i":0},{"t":4,"i":0}],"s":2},"o":0}"`;

exports[`objects > toCrossJSONAsync > supports Objects 1`] = `"{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":0}}"`;

exports[`objects > toCrossJSONAsync > supports Symbol.asyncIterator 1`] = `"{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":0}],"v":[{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[{"t":32,"i":4,"f":{"t":0,"s":1}},{"t":32,"i":4,"f":{"t":0,"s":2}},{"t":32,"i":4,"f":{"t":0,"s":3}},{"t":34,"i":4,"f":{"t":2,"s":1}}],"f":{"t":26,"i":5,"s":4}}]}],"s":1},"o":0}"`;

exports[`objects > toCrossJSONAsync > supports Symbol.iterator 1`] = `"{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":[{"t":17,"i":2,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":3,"f":{"t":4,"i":2}},{"t":10,"i":4,"p":{"k":["v","t","d"],"v":[{"t":9,"i":5,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":0}}"`;

exports[`objects > toCrossJSONAsync > supports self-recursion 1`] = `"{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":12,"i":1,"s":1,"f":{"t":4,"i":0}},{"t":12,"i":2,"s":1,"f":{"t":4,"i":0}}],"s":2},"o":0}"`;

exports[`objects > toCrossJSONStream > supports Objects 1`] = `"{"t":22,"i":0,"s":1,"f":{"t":26,"i":2,"s":1}}"`;

exports[`objects > toCrossJSONStream > supports Objects 2`] = `"{"t":23,"i":1,"a":[{"t":26,"i":4,"s":2},{"t":10,"i":3,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":0}]}"`;

exports[`objects > toCrossJSONStream > supports Symbol.asyncIterator 1`] = `"{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":0}],"v":[{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[],"f":{"t":26,"i":5,"s":4}}]}],"s":1},"o":0}"`;

exports[`objects > toCrossJSONStream > supports Symbol.asyncIterator 2`] = `"{"t":32,"i":4,"f":{"t":0,"s":1}}"`;

exports[`objects > toCrossJSONStream > supports Symbol.asyncIterator 3`] = `"{"t":32,"i":4,"f":{"t":0,"s":2}}"`;

exports[`objects > toCrossJSONStream > supports Symbol.asyncIterator 4`] = `"{"t":32,"i":4,"f":{"t":0,"s":3}}"`;

exports[`objects > toCrossJSONStream > supports Symbol.asyncIterator 5`] = `"{"t":34,"i":4,"f":{"t":2,"s":1}}"`;

exports[`objects > toCrossJSONStream > supports Symbol.iterator 1`] = `"{"t":22,"i":0,"s":1,"f":{"t":26,"i":2,"s":1}}"`;

exports[`objects > toCrossJSONStream > supports Symbol.iterator 2`] = `"{"t":23,"i":1,"a":[{"t":26,"i":8,"s":2},{"t":10,"i":3,"p":{"k":[{"t":17,"i":4,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":5,"f":{"t":4,"i":4}},{"t":10,"i":6,"p":{"k":["v","t","d"],"v":[{"t":9,"i":7,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":0}]}"`;

exports[`objects > toCrossJSONStream > supports self-recursion 1`] = `"{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":22,"i":1,"s":2,"f":{"t":26,"i":3,"s":1}},{"t":22,"i":4,"s":5,"f":{"t":4,"i":3}}],"s":2},"o":0}"`;

exports[`objects > toCrossJSONStream > supports self-recursion 2`] = `"{"t":23,"i":2,"a":[{"t":26,"i":6,"s":2},{"t":4,"i":0}]}"`;

exports[`objects > toCrossJSONStream > supports self-recursion 3`] = `"{"t":23,"i":5,"a":[{"t":4,"i":6},{"t":4,"i":0}]}"`;

exports[`objects > toJSON > supports Objects 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":0},"f":31,"m":[]}"`;

exports[`objects > toJSON > supports Symbol.iterator 1`] = `"{"t":{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":2,"f":{"t":4,"i":1}},{"t":10,"i":3,"p":{"k":["v","t","d"],"v":[{"t":9,"i":4,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":0},"f":31,"m":[1]}"`;

exports[`objects > toJSON > supports self-recursion 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":4,"i":0},{"t":4,"i":0}],"s":2},"o":0},"f":31,"m":[0]}"`;

exports[`objects > toJSONAsync > supports Objects 1`] = `"{"t":{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":["example","%example","0x1","0b1","0o1","1_000","1.7976931348623157e+308"],"v":[{"t":1,"s":"valid identifier"},{"t":1,"s":"invalid identifier"},{"t":1,"s":"hexadecimal"},{"t":1,"s":"binary"},{"t":1,"s":"octal"},{"t":1,"s":"numeric separator"},{"t":1,"s":"exponentiation"}],"s":7},"o":0}},"f":31,"m":[]}"`;

exports[`objects > toJSONAsync > supports Symbol.asyncIterator 1`] = `"{"t":{"t":10,"i":0,"p":{"k":[{"t":17,"i":1,"s":0}],"v":[{"t":30,"a":[{"t":29,"i":2,"a":[{"t":26,"i":3,"s":1},{"t":4,"i":1}]},{"t":31,"i":4,"a":[{"t":32,"i":4,"f":{"t":0,"s":1}},{"t":32,"i":4,"f":{"t":0,"s":2}},{"t":32,"i":4,"f":{"t":0,"s":3}},{"t":34,"i":4,"f":{"t":2,"s":1}}],"f":{"t":26,"i":5,"s":4}}]}],"s":1},"o":0},"f":31,"m":[1,4]}"`;

exports[`objects > toJSONAsync > supports Symbol.iterator 1`] = `"{"t":{"t":12,"i":0,"s":1,"f":{"t":10,"i":1,"p":{"k":[{"t":17,"i":2,"s":3}],"v":[{"t":28,"a":[{"t":27,"i":3,"f":{"t":4,"i":2}},{"t":10,"i":4,"p":{"k":["v","t","d"],"v":[{"t":9,"i":5,"l":4,"a":[{"t":0,"s":1},{"t":0,"s":2},{"t":0,"s":3},{"t":2,"s":1}],"o":0},{"t":0,"s":-1},{"t":0,"s":3}],"s":3},"o":0}]}],"s":1},"o":0}},"f":31,"m":[2]}"`;

exports[`objects > toJSONAsync > supports self-recursion 1`] = `"{"t":{"t":10,"i":0,"p":{"k":["a","b"],"v":[{"t":12,"i":1,"s":1,"f":{"t":4,"i":0}},{"t":12,"i":2,"s":1,"f":{"t":4,"i":0}}],"s":2},"o":0},"f":31,"m":[0]}"`;
