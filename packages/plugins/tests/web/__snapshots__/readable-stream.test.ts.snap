// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ReadableStream > crossSerializeAsync > scoped > supports ReadableStream 1`] = `
"($R=>$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))(($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[2].next("foo"),$R[2].next("bar"),$R[2].next("baz"),$R[2].return(void 0),$R[2])))($R["example"])"
`;

exports[`ReadableStream > crossSerializeAsync > scoped > supports ReadableStream errors 1`] = `
"($R=>$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))(($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[2].throw($R[4]=Object.assign(new Error("Oops!"),{stack:""})),$R[2])))($R["example"])"
`;

exports[`ReadableStream > crossSerializeAsync > supports ReadableStream 1`] = `
"$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))(($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[2].next("foo"),$R[2].next("bar"),$R[2].next("baz"),$R[2].return(void 0),$R[2]))"
`;

exports[`ReadableStream > crossSerializeAsync > supports ReadableStream errors 1`] = `
"$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))(($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),$R[2].throw($R[4]=Object.assign(new Error("Oops!"),{stack:""})),$R[2]))"
`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream 1`] = `
"($R=>$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})()))($R["example"])"
`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream 2`] = `"($R=>$R[2].next("foo"))($R["example"])"`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream 3`] = `"($R=>$R[2].next("bar"))($R["example"])"`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream 4`] = `"($R=>$R[2].next("baz"))($R["example"])"`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream 5`] = `"($R=>$R[2].return(void 0))($R["example"])"`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream errors 1`] = `
"($R=>$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})()))($R["example"])"
`;

exports[`ReadableStream > crossSerializeStream > scoped > supports ReadableStream errors 2`] = `"($R=>$R[2].throw($R[4]=Object.assign(new Error("Oops!"),{stack:""})))($R["example"])"`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream 1`] = `
"$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})())"
`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream 2`] = `"$R[2].next("foo")"`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream 3`] = `"$R[2].next("bar")"`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream 4`] = `"$R[2].next("baz")"`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream 5`] = `"$R[2].return(void 0)"`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream errors 1`] = `
"$R[0]=($R[1]=(stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))($R[2]=($R[3]=() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})())"
`;

exports[`ReadableStream > crossSerializeStream > supports ReadableStream errors 2`] = `"$R[2].throw($R[4]=Object.assign(new Error("Oops!"),{stack:""}))"`;

exports[`ReadableStream > serializeAsync > supports ReadableStream 1`] = `
"(h=>((stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))((h=(() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),h.next("foo"),h.next("bar"),h.next("baz"),h.return(void 0),h)))()"
`;

exports[`ReadableStream > serializeAsync > supports ReadableStream errors 1`] = `
"(h=>((stream) => new ReadableStream({
  start: (controller) => {
    stream.on({
      next: (value) => {
        try {
          controller.enqueue(value);
        } catch (_error) {
        }
      },
      throw: (value) => {
        controller.error(value);
      },
      return: () => {
        try {
          controller.close();
        } catch (_error) {
        }
      }
    });
  }
}))((h=(() => {
  const buffer = [];
  const listeners = [];
  let alive = true;
  let success = false;
  let count = 0;
  const flush = (value, mode, x) => {
    for (x = 0; x < count; x++) {
      if (listeners[x]) {
        listeners[x][mode](value);
      }
    }
  };
  const up = (listener, x, z, current) => {
    for (x = 0, z = buffer.length; x < z; x++) {
      current = buffer[x];
      if (!alive && x === z - 1) {
        listener[success ? "return" : "throw"](current);
      } else {
        listener.next(current);
      }
    }
  };
  const on = (listener, temp) => {
    if (alive) {
      temp = count++;
      listeners[temp] = listener;
    };
    up(listener);
    return () => {
      if (alive) {
        listeners[temp] = listeners[count];
        listeners[count--] = void 0;
      }
    };
  };
  return {
    __SEROVAL_STREAM__: true,
    on: (listener) => on(listener),
    next: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "next");
      }
    },
    throw: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "throw");
        alive = false;
        success = false;
        listeners.length = 0;
      }
    },
    return: (value) => {
      if (alive) {
        buffer.push(value);
        flush(value, "return");
        alive = false;
        success = true;
        listeners.length = 0;
      }
    }
  };
})(),h.throw(Object.assign(new Error("Oops!"),{stack:""})),h)))()"
`;

exports[`ReadableStream > serializeAsync > supports ReadableStream errors 2`] = `[Error: Oops!]`;

exports[`ReadableStream > toCrossJSONAsync > supports ReadableStream 1`] = `"{"t":25,"i":0,"s":{"factory":{"t":25,"i":1,"c":"seroval-plugins/web/ReadableStreamFactory"},"stream":{"t":31,"i":2,"a":[{"t":32,"i":2,"f":{"t":1,"s":"foo"}},{"t":32,"i":2,"f":{"t":1,"s":"bar"}},{"t":32,"i":2,"f":{"t":1,"s":"baz"}},{"t":34,"i":2,"f":{"t":2,"s":1}}],"f":{"t":26,"i":3,"s":4}}},"c":"seroval/plugins/web/ReadableStream"}"`;

exports[`ReadableStream > toCrossJSONAsync > supports ReadableStream errors 1`] = `"{"t":25,"i":0,"s":{"factory":{"t":25,"i":1,"c":"seroval-plugins/web/ReadableStreamFactory"},"stream":{"t":31,"i":2,"a":[{"t":33,"i":2,"f":{"t":13,"i":4,"s":0,"m":"Oops!","p":{"k":["stack"],"v":[{"t":1,"s":""}]}}}],"f":{"t":26,"i":3,"s":4}}},"c":"seroval/plugins/web/ReadableStream"}"`;

exports[`ReadableStream > toCrossJSONAsync > supports ReadableStream errors 2`] = `[Error: Oops!]`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream 1`] = `"{"t":25,"i":0,"s":{"factory":{"t":25,"i":1,"c":"seroval-plugins/web/ReadableStreamFactory"},"stream":{"t":31,"i":2,"a":[],"f":{"t":26,"i":3,"s":4}}},"c":"seroval/plugins/web/ReadableStream"}"`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream 2`] = `"{"t":32,"i":2,"f":{"t":1,"s":"foo"}}"`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream 3`] = `"{"t":32,"i":2,"f":{"t":1,"s":"bar"}}"`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream 4`] = `"{"t":32,"i":2,"f":{"t":1,"s":"baz"}}"`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream 5`] = `"{"t":34,"i":2,"f":{"t":2,"s":1}}"`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream errors 1`] = `"{"t":25,"i":0,"s":{"factory":{"t":25,"i":1,"c":"seroval-plugins/web/ReadableStreamFactory"},"stream":{"t":31,"i":2,"a":[],"f":{"t":26,"i":3,"s":4}}},"c":"seroval/plugins/web/ReadableStream"}"`;

exports[`ReadableStream > toCrossJSONStream > supports ReadableStream errors 2`] = `"{"t":33,"i":2,"f":{"t":13,"i":4,"s":0,"m":"Oops!","p":{"k":["stack"],"v":[{"t":1,"s":""}]}}}"`;

exports[`ReadableStream > toJSONAsync > supports ReadableStream 1`] = `"{"t":{"t":25,"i":0,"s":{"factory":{"t":25,"i":1,"c":"seroval-plugins/web/ReadableStreamFactory"},"stream":{"t":31,"i":2,"a":[{"t":32,"i":2,"f":{"t":1,"s":"foo"}},{"t":32,"i":2,"f":{"t":1,"s":"bar"}},{"t":32,"i":2,"f":{"t":1,"s":"baz"}},{"t":34,"i":2,"f":{"t":2,"s":1}}],"f":{"t":26,"i":3,"s":4}}},"c":"seroval/plugins/web/ReadableStream"},"f":63,"m":[2]}"`;

exports[`ReadableStream > toJSONAsync > supports ReadableStream errors 1`] = `"{"t":{"t":25,"i":0,"s":{"factory":{"t":25,"i":1,"c":"seroval-plugins/web/ReadableStreamFactory"},"stream":{"t":31,"i":2,"a":[{"t":33,"i":2,"f":{"t":13,"i":4,"s":0,"m":"Oops!","p":{"k":["stack"],"v":[{"t":1,"s":""}]}}}],"f":{"t":26,"i":3,"s":4}}},"c":"seroval/plugins/web/ReadableStream"},"f":63,"m":[2]}"`;

exports[`ReadableStream > toJSONAsync > supports ReadableStream errors 2`] = `[Error: Oops!]`;
